using System;
using System.Collections.Generic;
using UnityEngine;

public static class LinearAlgebra {

    public static Vector3 XAxis { get => Vector3.right; }
    public static Vector3 YAxis { get => Vector3.up; }

    public static Vector3 ZAxis { get => new Vector3(0, 0, 1); }

    public static Vector3 GetMeanInSpace(ICollection<Vector3> points) {
        float sumX = 0;
        float sumY = 0;
        float sumZ = 0;

        foreach (var point in points) {
            sumX += point.x;
            sumY += point.y;
            sumZ += point.z;
        }

        return new Vector3(sumX / points.Count, sumY / points.Count, sumZ / points.Count);
    }
}

public class BoundingBoxXZ {
    float AGENT_NAVMESH_BOUNDS_Y = 5f;
    public float minX;
    public float maxX;

    public float minZ;
    public float maxZ;

    public Vector3 BottomLeft {
        get => new Vector3(minX, 0, minZ);
    }
    public Vector3 TopLeft {
        get => new Vector3(minX, 0, maxZ);
    }
    public Vector3 BottomRight {
        get => new Vector3(maxX, 0, minZ);
    }
    public Vector3 TopRight {
        get => new Vector3(maxX, 0, maxZ);
    }
    public Vector3 center {
        get => Vector3.Scale(BottomLeft + TopRight, new Vector3(.5f, 0, .5f));
    }
    public Vector3 size {
        get => new Vector3(Math.Abs(maxX - minX), AGENT_NAVMESH_BOUNDS_Y, Math.Abs(maxZ - minZ));
    }

    public BoundingBoxXZ () {
        minX = 1e9f;
        maxX = -1e9f;
        minZ = 1e9f;
        maxZ = -1e9f;
    }
    public BoundingBoxXZ (
        float minX,
        float maxX,
        float minZ,
        float maxZ
    ) {
        this.minX = minX;
        this.maxX = maxX;
        this.minZ = minZ;
        this.maxZ = maxZ;
    }
}using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public static class AgentClustering
{

    static Vector3 AGENT_NAVMESH_BOUNDS_SIZE = new Vector3(30f, 5f, 30f);


    public static Dictionary<(int, int), List<GameObject>> ClusterAgents () {
        // get all agents
        var agents = new List<GameObject>(GameObject.FindGameObjectsWithTag("Agent"));

        // sort agents by x axis
        var agentsX = agents.OrderBy(agent => agent.transform.position.x).ToList();
        // sort agents by z axis
        var agentsZ = agents.OrderBy(agent => agent.transform.position.z).ToList();

        // group agents by x axis
        List<List<GameObject>> agentClustersX = GroupAgents(agentsX, LinearAlgebra.XAxis);
        // group agents by z axis
        List<List<GameObject>> agentClustersZ = GroupAgents(agentsZ, LinearAlgebra.ZAxis);

        return CombineClusters(agentClustersX, agentClustersZ);
    }

    static List<List<GameObject>> GroupAgents(List<GameObject> agents, Vector3 direction) {

        List<List<GameObject>> agentClusters = new List<List<GameObject>>();

        List<GameObject> currentCluster = new List<GameObject>();
        for (int i = 0; i < agents.Count; i++) {
            if (i == 0) {
                currentCluster.Add(agents[i]);
                continue;
            }

            bool isInCluster = false;

            // check by x axis
            if(direction == LinearAlgebra.XAxis) {
                if(Math.Abs(agents[i].transform.position.x - currentCluster[0].transform.position.x) < AGENT_NAVMESH_BOUNDS_SIZE.x) {
                    isInCluster = true;
                }
            }
            else if(direction == LinearAlgebra.ZAxis) {
                if(Math.Abs(agents[i].transform.position.z - currentCluster[0].transform.position.z) < AGENT_NAVMESH_BOUNDS_SIZE.x) {
                    isInCluster = true;
                }
            }

            if(isInCluster) {
                currentCluster.Add(agents[i]);
            } 
            else {
                agentClusters.Add(currentCluster);
                currentCluster = new List<GameObject>
                {
                    agents[i]
                };
            }
        }

        // add the last cluster
        agentClusters.Add(currentCluster);
        return agentClusters;
    }

    static Dictionary<(int, int), List<GameObject>> CombineClusters(
        List<List<GameObject>> agentClustersX, 
        List<List<GameObject>> agentClustersZ)
    {
        // Create a dictionary to store the combined clusters
        Dictionary<(int, int), List<GameObject>> combinedClusters = new Dictionary<(int, int), List<GameObject>>();

        // Map each GameObject to its cluster index in the x axis
        Dictionary<GameObject, int> xClusterMap = new Dictionary<GameObject, int>();
        for (int i = 0; i < agentClustersX.Count; i++)
        {
            foreach (var agent in agentClustersX[i])
            {
                xClusterMap[agent] = i;
            }
        }

        // Map each GameObject to its cluster index in the z axis
        Dictionary<GameObject, int> zClusterMap = new Dictionary<GameObject, int>();
        for (int i = 0; i < agentClustersZ.Count; i++)
        {
            foreach (var agent in agentClustersZ[i])
            {
                zClusterMap[agent] = i;
            }
        }

        // Combine clusters
        foreach (var agent in xClusterMap.Keys)
        {
            int xCluster = xClusterMap[agent];
            int zCluster = zClusterMap[agent];

            var combinedKey = (xCluster, zCluster);
            if (!combinedClusters.ContainsKey(combinedKey))
            {
                combinedClusters[combinedKey] = new List<GameObject>();
            }
            combinedClusters[combinedKey].Add(agent);
        }
        return combinedClusters;
    }
}using UnityEngine;
using UnityEngine.AI;
using System;

public class AgentMovement : MonoBehaviour
{
    bool navMeshAgentSet = false;
    NavMeshAgent navMeshAgent;

    Vector3[] waypoints = {
        new Vector3(32.04f, 0.0f, -49.81f),
        new Vector3(12.33f, 0.0f, -22.01f),
        new Vector3(3.33f, 0.0f, 3.72f),
        new Vector3(20.17f, 0.0f, -48.17f),
        new Vector3(34.28f, 0.0f, 55.02f),
        new Vector3(69.96f, 0.0f, 57.92f),
        new Vector3(-47.92f, 0.0f, -74.73f),
        new Vector3(-65.81f, 0.0f, -38.81f),
        new Vector3(11.01f, 0.0f, 73.63f),
        new Vector3(16.80f, 0.0f, -1.47f),
        new Vector3(-26.10f, 0.0f, 60.69f),
        new Vector3(-42.91f, 0.0f, -45.88f),
        new Vector3(-43.39f, 0.0f, -27.15f),
        new Vector3(-48.67f, 0.0f, 48.87f),
        new Vector3(-22.31f, 0.0f, 45.46f),
        new Vector3(72.68f, 0.0f, -24.35f),
        new Vector3(-50.16f, 0.0f, -46.99f),
        new Vector3(-72.02f, 0.0f, -65.48f),
        new Vector3(30.58f, 0.0f, -26.77f),
        new Vector3(-59.95f, 0.0f, -51.72f),
        new Vector3(54.78f, 0.0f, -23.97f),
        new Vector3(41.58f, 0.0f, -61.39f),
        new Vector3(52.10f, 0.0f, -22.05f),
        new Vector3(10.63f, 0.0f, 42.72f),
        new Vector3(46.59f, 0.0f, 68.07f),
        new Vector3(55.33f, 0.0f, 31.26f),
        new Vector3(-49.81f, 0.0f, 24.06f),
        new Vector3(-64.31f, 0.0f, 0.91f),
        new Vector3(40.95f, 0.0f, -31.31f),
        new Vector3(-9.83f, 0.0f, 19.08f),
        new Vector3(66.11f, 0.0f, 32.35f),
        new Vector3(60.19f, 0.0f, -40.50f),
        new Vector3(4.64f, 0.0f, -64.63f),
        new Vector3(34.85f, 0.0f, -8.57f),
        new Vector3(12.63f, 0.0f, 12.34f),
        new Vector3(-66.15f, 0.0f, 67.55f),
        new Vector3(71.81f, 0.0f, 69.82f),
        new Vector3(55.44f, 0.0f, 72.66f),
        new Vector3(45.33f, 0.0f, -69.21f),
        new Vector3(19.05f, 0.0f, 14.65f),
        new Vector3(-12.79f, 0.0f, -16.82f),
        new Vector3(27.21f, 0.0f, 23.23f),
        new Vector3(40.51f, 0.0f, 56.53f),
        new Vector3(27.92f, 0.0f, 8.09f),
        new Vector3(-37.94f, 0.0f, -74.01f),
        new Vector3(-61.81f, 0.0f, -34.02f),
        new Vector3(-36.47f, 0.0f, -10.00f),
        new Vector3(64.01f, 0.0f, 24.91f),
        new Vector3(55.21f, 0.0f, -14.52f),
        new Vector3(-10.29f, 0.0f, -53.87f)
    };

    Vector3 GetRandomWaypoint() {
        var index = UnityEngine.Random.Range(0, waypoints.Length - 1);
        return waypoints[index];
    }
    Vector3 GetNextPosition() {
        // TODO: Implement some more interesting movement
        return transform.position + new Vector3(-1, 0, 1);
    }

    // Start is called before the first frame update
    void Start()
    {
        navMeshAgent = GetComponent<NavMeshAgent>();
    }

    // Update is called once per frame
    void Update()
    {
        if(!navMeshAgent) {
            navMeshAgent = GetComponent<NavMeshAgent>();
        }
        if(navMeshAgent) {
            if(!navMeshAgentSet) {
                navMeshAgentSet = true;
                navMeshAgent.SetDestination(GetRandomWaypoint());
            }
            else if (navMeshAgent.remainingDistance < navMeshAgent.stoppingDistance) {
                navMeshAgent.SetDestination(GetRandomWaypoint());
            }
        }
    }
}
public enum DynamicNavMeshState {
    Build,
    Building,
    Destroy,
    Destroying,
    Ready
};using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine.AI;

public class GlobalNavMeshController : MonoBehaviour
{   
    public GameObject navMeshBuilderObject;
    NavMeshBuilder navMeshBuilder;

    List<GameObject> agents = new List<GameObject>();
    Dictionary<(int, int), DynamicNavMeshController> navMeshSurfaces = new Dictionary<(int, int), DynamicNavMeshController>();
    Queue<DynamicNavMeshController> updateQueue = new Queue<DynamicNavMeshController>();

    float UPDATE_DELAY = .1f;
    
    bool shouldUpdate = false;
    public bool ShouldUpdate { get => shouldUpdate; }
    public void MarkForUpdate() {
        shouldUpdate = true;
    }
    public void FinishUpdate() {
        shouldUpdate = false;
    }

    void Awake() {
        navMeshBuilder = navMeshBuilderObject.GetComponent<NavMeshBuilder>();
    }

    void Start() 
    {
        // Find all agents and save them into the array
        agents = World.GetAllAgents();
        
        // mark for first update
        MarkForUpdate();

        // start the update queue
        StartCoroutine(ProcessUpdateQueue());
    }

    void Update() {
        if(shouldUpdate) {
            RecalculateNavMeshes();
        }
    }

    IEnumerator ProcessUpdateQueue()
    {
        while (true)
        {
            if (updateQueue.Count > 0)
            {
                var surfaceController = updateQueue.Dequeue();
                if(surfaceController.State == DynamicNavMeshState.Build)
                {
                    surfaceController.State = DynamicNavMeshState.Building;
                    surfaceController.BuildNavMesh();
                }
                
                else if(surfaceController.State == DynamicNavMeshState.Destroy)
                {
                    surfaceController.State = DynamicNavMeshState.Destroying;
                    Destroy(surfaceController.gameObject);
                }
            }
            yield return new WaitForSeconds(UPDATE_DELAY);
        }
    }

    void RecalculateNavMeshes() {

        // TODO: optimize further by only recalculating the affected navmeshes

        // cluster agents
        var agentClusters = AgentClustering.ClusterAgents();

        // deactivate all agents
        foreach(var agent in agents) {
            var navMeshAgent = agent.GetComponent<NavMeshAgent>();
            navMeshAgent.isStopped = true;
        }

        // mark all surfaces for destruction
        foreach( var (_, surfaceController) in navMeshSurfaces ) {
            surfaceController.State = DynamicNavMeshState.Destroy;
            updateQueue.Enqueue(surfaceController);
        }
        
        // from agent clusters, create navmesh surfaces
        navMeshSurfaces = navMeshBuilder.BuildNavMeshesFromAgentClusters(agentClusters);
        foreach( var (_, surfaceController) in navMeshSurfaces ) {
            // assign the global navmesh controller
            surfaceController.GlobalNavMeshController = this;
            updateQueue.Enqueue(surfaceController);
        }

        FinishUpdate();
    }
}using System.Collections.Generic;
using UnityEngine;

public class NavMeshBuilder : MonoBehaviour
{
    float BOUNDING_BOX_PADDING_X = 10f;
    float BOUNDING_BOX_PADDING_Z = 10f;
    public GameObject dynamicNavMeshPrefab;

    public Dictionary<(int, int), DynamicNavMeshController> BuildNavMeshesFromAgentClusters(
        Dictionary<(int, int), List<GameObject>> agentClusters
    )
    {
        var navMeshSurfaces = new Dictionary<(int, int), DynamicNavMeshController>();

        foreach (var (key, cluster) in agentClusters)
        {
            BoundingBoxXZ boundingBox = GetBoundingBox(cluster);
            var navMeshSurface = InstantiateDynamicNavMeshSurface(boundingBox.center);
            var surfaceController = navMeshSurface.GetComponent<DynamicNavMeshController>();

            surfaceController.SetNavMeshBounds(
                new Bounds(boundingBox.center, boundingBox.size)
            );
            navMeshSurfaces[key] = surfaceController;
        }

        return navMeshSurfaces;
    }

    GameObject InstantiateDynamicNavMeshSurface(Vector3 center) {
        // maybe change later
        center.y = 0;

        var navMeshSurface = Instantiate (
            dynamicNavMeshPrefab,
            center,
            Quaternion.identity
        );

        // return the navMeshSurface
        return navMeshSurface;
    }

    BoundingBoxXZ GetBoundingBox(List<GameObject> agentCluster) {
        
        BoundingBoxXZ boundingBox = new BoundingBoxXZ();

        foreach(var agent in agentCluster) {
            boundingBox.minX = Mathf.Min(boundingBox.minX, agent.transform.position.x);
            boundingBox.maxX = Mathf.Max(boundingBox.maxX, agent.transform.position.x);
            boundingBox.minZ = Mathf.Min(boundingBox.minZ, agent.transform.position.z);
            boundingBox.maxZ = Mathf.Max(boundingBox.maxZ, agent.transform.position.z);
        }

        // increase the bounding box size by some fixed padding
        boundingBox.minX -= BOUNDING_BOX_PADDING_X;
        boundingBox.maxX += BOUNDING_BOX_PADDING_X;
        boundingBox.minZ -= BOUNDING_BOX_PADDING_Z;
        boundingBox.maxZ += BOUNDING_BOX_PADDING_Z;

        return boundingBox;
    }
}
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public static class World
{
    const string AGENT_TAG = "Agent";
    public static List<GameObject> GetActiveAgents()
    {
        return new List<GameObject>(GameObject.FindGameObjectsWithTag(AGENT_TAG));
    }

    public static List<GameObject> GetAllAgents()
    {
        GameObject[] allObjects = Resources.FindObjectsOfTypeAll(typeof(GameObject)) as GameObject[];

        // Create a list to store all GameObjects with the specified tag
        List<GameObject> agents = new List<GameObject>();

        // Iterate through allObjects and add those with the specified tag to the agents list
        foreach (GameObject obj in allObjects)
        {
            if (obj.CompareTag(AGENT_TAG))
            {
                agents.Add(obj);
            }
        }

        return agents;
    }
}
using UnityEngine;
using UnityEngine.AI;
using System.Collections.Generic;
using Unity.AI.Navigation;
using UnityEditor;

public class DynamicNavMeshController : MonoBehaviour
{
    public GUID id;
    public DynamicNavMeshState State;
    public NavMeshSurface navMeshSurface;
    public GlobalNavMeshController GlobalNavMeshController {get; set;}
    List<GameObject> agents;
    List<GameObject> agentsInside;
    Bounds navMeshBounds;
    Bounds smallerBounds;
    
    // PUBLIC GETTERS
    public Bounds NavMeshBounds { get => navMeshBounds; }
    public Bounds SmallerBounds { get => smallerBounds; }
    public List<GameObject> AgentsInside { get => agentsInside; }

    void Awake() 
    {
        id = GUID.Generate();
        State = DynamicNavMeshState.Build;
        navMeshSurface = GetComponent<NavMeshSurface>();

        if (navMeshSurface.navMeshData == null)
        {
            navMeshSurface.navMeshData = new NavMeshData();
            NavMesh.AddNavMeshData(navMeshSurface.navMeshData);
        }
    }

    void Start() 
    {
        agents = World.GetAllAgents();
        agentsInside = new List<GameObject>();
    }

    public void SetNavMeshBounds(Bounds bounds) {
        navMeshBounds = bounds;
        smallerBounds = new Bounds(bounds.center, bounds.size - new Vector3(10f, 0f, 10f));
    }

    void Update() 
    {
        // only update if the navmeshsurface is not in the update process already
        if(State == DynamicNavMeshState.Ready) {
            agents = new List<GameObject>(GameObject.FindGameObjectsWithTag("Agent"));
    
            foreach (var agent in agents) {
                if(navMeshBounds.Contains(agent.transform.position)) {
                    agentsInside.Add(agent);
                }
            }
            foreach (var agent in agentsInside) {
                if(!smallerBounds.Contains(agent.transform.position)) {
                    // mark for update
                    GlobalNavMeshController.MarkForUpdate();
                }
            }
        }
    }

    public void BuildNavMesh() {
        
        navMeshSurface.collectObjects = CollectObjects.Volume;
        navMeshSurface.center = Vector3.zero;
        navMeshSurface.size = new Vector3(
            navMeshBounds.size.x,
            0,
            navMeshBounds.size.z
        );

        navMeshSurface.BuildNavMesh();
        State = DynamicNavMeshState.Ready;

        foreach (var agent in agents) {
            var center = new Vector3(
                transform.position.x,
                0,
                transform.position.z
            );
            if(navMeshBounds.Contains(agent.transform.position - Vector3.up)) {
                agentsInside.Add(agent);
            }
        }

        agentsInside.ForEach(agent => ReactivateAgentIfOnNavMesh(agent));
    }

    private void ReactivateAgentIfOnNavMesh(GameObject agent)
    {
        NavMeshHit hit;
        if (NavMesh.SamplePosition(agent.transform.position, out hit, 1.0f, NavMesh.AllAreas))
        {
            if(!agent.GetComponent<NavMeshAgent>()) {
                agent.AddComponent<NavMeshAgent>();
            }
            agent.transform.position = hit.position;
            var navMeshAgent = agent.GetComponent<NavMeshAgent>();
            navMeshAgent.stoppingDistance = 0.1f;
            
            navMeshAgent.isStopped = false;
        } 
    }
}